<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Adaptive Predictive Keyboard</title>
   <style>
       body {
           font-family: 'Arial', sans-serif;
           background-color: #2a2a2a;
           color: white;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           height: 100vh;
           margin: 0;
           padding: 20px;
           box-sizing: border-box;
       }

       #text-display {
           font-size: 28px;
           height: 50px;
           margin-bottom: 40px;
           padding: 10px;
           background-color: #333;
           border-radius: 8px;
           width: 80%;
           max-width: 600px;
           text-align: center;
       }

       #learning-indicator {
           position: absolute;
           top: 20px;
           right: 20px;
           background-color: #444;
           padding: 8px 12px;
           border-radius: 20px;
           font-size: 12px;
           color: #aaa;
           transition: all 0.3s ease;
       }

       #learning-indicator.active {
           background-color: #0a5c2e;
           color: #4ade80;
           box-shadow: 0 0 10px rgba(74, 222, 128, 0.3);
       }

       #keyboard {
           display: flex;
           flex-direction: column;
           gap: 10px;
           width: 80%;
           max-width: 700px;
       }

       .keyboard-row {
           display: flex;
           justify-content: center;
           gap: 5px;
       }

       .key {
           background-color: #444;
           border: 1px solid #555;
           border-radius: 6px;
           display: flex;
           align-items: center;
           justify-content: center;
           cursor: pointer;
           transition: all 0.2s ease;
           user-select: none;
           width: 40px;
           height: 40px;
       }
      
       .key:hover {
           background-color: #555;
       }
      
       .key:active {
           background-color: #666;
           transform: translateY(2px);
       }

       #instructions {
           margin-top: 30px;
           font-size: 16px;
           color: #aaa;
           text-align: center;
       }

       .spacebar {
           width: 200px;
       }

       .backspace {
           width: 80px;
       }

       #stats {
           position: absolute;
           bottom: 20px;
           left: 20px;
           font-size: 12px;
           color: #666;
           background-color: #333;
           padding: 10px;
           border-radius: 6px;
       }
   </style>
</head>
<body>
  
   <h2 id="example-text"><b>Start typing - the keyboard learns as you go!</b></h2>
   <div id="learning-indicator">ðŸ§  Learning Mode</div>
   <div id="text-display">|</div>
   
   <div id="keyboard">
       <div class="keyboard-row" id="row1"></div>
       <div class="keyboard-row" id="row2"></div>
       <div class="keyboard-row" id="row3"></div>
       <div class="keyboard-row">
           <div class="key backspace" id="backspace">âŒ«</div>
           <div class="key spacebar" id="space">Space</div>
           <div class="key backspace" id="clear">Clear</div>
       </div>
   </div>
   
   <div id="instructions">
       Type using your keyboard or click the virtual keys<br>
       Larger keys = predicted next letters<br>
       The keyboard learns from your typing patterns automatically
   </div>

   <div id="stats">
       <div>Words learned: <span id="words-count">0</span></div>
       <div>Patterns learned: <span id="patterns-count">0</span></div>
   </div>

   <script>
       // Current text state
       let currentText = "";
       let lastCompletedWord = "";
       let typingBuffer = "";
       let learningStats = { words: 0, patterns: 0 };
      
       // Keyboard layout
       const keyboardLayout = [
           ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
           ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'],
           ['z', 'x', 'c', 'v', 'b', 'n', 'm']
       ];
      
       // Predictive model data
       const letterPairs = {};
       const commonWords = new Set();
       let predictedLetters = [];
      
       // Create the keyboard
       function createKeyboard() {
           for (let i = 0; i < keyboardLayout.length; i++) {
               const rowEl = document.getElementById(row${i+1});
              
               for (let j = 0; j < keyboardLayout[i].length; j++) {
                   const letter = keyboardLayout[i][j];
                   const key = document.createElement('div');
                   key.className = 'key';
                   key.id = key-${letter};
                   key.textContent = letter;
                   key.addEventListener('click', () => handleKeyClick(letter));
                   rowEl.appendChild(key);
               }
           }
       }
      
       // Handle keyboard clicks
       function handleKeyClick(letter) {
           addToTypingBuffer(letter);
           currentText += letter;
           updateDisplay();
           predictNextLetters();
           updateVisualPredictions();
       }
      
       // Handle physical keyboard input
       document.addEventListener('keydown', (event) => {
           const key = event.key.toLowerCase();
          
           if (/^[a-z]$/.test(key)) {
               addToTypingBuffer(key);
               currentText += key;
               updateDisplay();
               predictNextLetters();
               updateVisualPredictions();
           } else if (event.key === 'Backspace') {
               handleBackspace();
           } else if (event.key === ' ') {
               addToTypingBuffer(' ');
               currentText += ' ';
               updateDisplay();
               predictNextLetters();
               updateVisualPredictions();
           }
       });
      
       // Add character to typing buffer for learning
       function addToTypingBuffer(char) {
           typingBuffer += char;
           
           // Learn from completed words (when space is typed)
           if (char === ' ') {
               const words = typingBuffer.trim().split(/\s+/);
               for (const word of words) {
                   if (word.length > 1) {
                       learnFromWord(word);
                       showLearningIndicator();
                   }
               }
               typingBuffer = "";
           }
           
           // Also learn from longer phrases (every 20 characters)
           if (typingBuffer.length >= 20) {
               learnFromPhrase(typingBuffer);
               typingBuffer = typingBuffer.slice(-10); // Keep last 10 chars for context
           }
       }
      
       // Learn patterns from a single word
       function learnFromWord(word) {
           if (!word || word.length <= 1) return;
           
           word = word.toLowerCase().trim();
           
           // Add to vocabulary if new
           if (!commonWords.has(word)) {
               commonWords.add(word);
               learningStats.words++;
               updateStats();
           }
           
           // Learn letter patterns with adaptive weighting
           const baseWeight = Math.min(word.length, 8); // Longer words get more weight
           
           // Single letter context
           for (let i = 0; i < word.length - 1; i++) {
               const context = word[i];
               const nextChar = word[i + 1];
               addLetterPattern(context, nextChar, baseWeight);
           }
           
           // Two letter context (more important for learning)
           for (let i = 0; i < word.length - 2; i++) {
               const context = word.substring(i, i + 2);
               const nextChar = word[i + 2];
               addLetterPattern(context, nextChar, baseWeight * 2);
           }
           
           // Three letter context (most important for user-specific patterns)
           for (let i = 0; i < word.length - 3; i++) {
               const context = word.substring(i, i + 3);
               const nextChar = word[i + 3];
               addLetterPattern(context, nextChar, baseWeight * 3);
           }
       }
       
       // Learn from longer phrases
       function learnFromPhrase(phrase) {
           const words = phrase.toLowerCase().split(/\s+/);
           for (const word of words) {
               if (word.length > 1) {
                   learnFromWord(word);
               }
           }
       }
       
       // Add a letter pattern to the model
       function addLetterPattern(context, next, weight) {
           if (!letterPairs[context]) {
               letterPairs[context] = {};
           }
           
           const oldWeight = letterPairs[context][next] || 0;
           letterPairs[context][next] = oldWeight + weight;
           
           if (oldWeight === 0) {
               learningStats.patterns++;
           }
       }
       
       // Show learning indicator animation
       function showLearningIndicator() {
           const indicator = document.getElementById('learning-indicator');
           indicator.classList.add('active');
           setTimeout(() => {
               indicator.classList.remove('active');
           }, 1000);
       }
       
       // Update learning statistics
       function updateStats() {
           document.getElementById('words-count').textContent = learningStats.words;
           document.getElementById('patterns-count').textContent = learningStats.patterns;
       }
      
       // Handle backspace button
       document.getElementById('backspace').addEventListener('click', handleBackspace);
      
       function handleBackspace() {
           if (currentText.length > 0) {
               // Remove from typing buffer too
               if (typingBuffer.length > 0) {
                   typingBuffer = typingBuffer.slice(0, -1);
               }
               
               currentText = currentText.substring(0, currentText.length - 1);
               updateDisplay();
               predictNextLetters();
               updateVisualPredictions();
           }
       }
      
       // Handle space button
       document.getElementById('space').addEventListener('click', () => {
           addToTypingBuffer(' ');
           currentText += ' ';
           updateDisplay();
           predictNextLetters();
           updateVisualPredictions();
       });
      
       // Handle clear button
       document.getElementById('clear').addEventListener('click', () => {
           currentText = '';
           typingBuffer = '';
           updateDisplay();
           predictNextLetters();
           updateVisualPredictions();
       });
      
       // Update the text display
       function updateDisplay() {
           document.getElementById('text-display').textContent = currentText + '|';
       }
      
       // Update visual keyboard to show predictions
       function updateVisualPredictions() {
           // Reset all keys to default appearance
           for (let row of keyboardLayout) {
               for (let letter of row) {
                   const key = document.getElementById(key-${letter});
                   key.style.backgroundColor = '#444';
                   key.style.width = '40px';
                   key.style.height = '40px';
                   key.style.fontSize = '16px';
               }
           }
          
           // Highlight and resize predicted letters
           for (let i = 0; i < predictedLetters.length; i++) {
               const letter = predictedLetters[i].letter;
               const score = predictedLetters[i].score;
               const key = document.getElementById(key-${letter});
              
               if (key) {
                   let scale;
                   let color;
                  
                   if (i === 0) {
                       scale = 1.8;
                       color = 'rgb(50, 150, 170)';  // Best prediction - brighter
                   } else if (i < 3) {
                       scale = 1.5 - i * 0.1;
                       color = 'rgb(60, 130, 150)';  // Top 3
                   } else if (i < 5) {
                       scale = 1.3;
                       color = 'rgb(70, 110, 130)';  // Top 5
                   } else {
                       scale = 1.15;
                       color = 'rgb(80, 90, 110)';   // Others
                   }
                  
                   key.style.backgroundColor = color;
                   key.style.width = ${40 * scale}px;
                   key.style.height = ${40 * scale}px;
                   key.style.fontSize = ${16 * Math.sqrt(scale)}px;
                   key.style.zIndex = 10 - i;
               }
           }
       }
      
       // Get next letter predictions based on current text
       function predictNextLetters() {
           const predictions = {};
          
           if (currentText.length === 0) {
               predictedLetters = [];
               return;
           }
          
           // Get current word
           const lastSpaceIndex = currentText.lastIndexOf(' ');
           const currentWord = lastSpaceIndex !== -1 ?
                             currentText.substring(lastSpaceIndex + 1) :
                             currentText;
          
           if (currentWord.length === 0) {
               // At beginning of new word - predict common starting letters
               addCommonStartingLetters(predictions);
           } else {
               // Use learned patterns for prediction
               
               // Try 3-character context first (most specific)
               if (currentWord.length >= 3) {
                   const context = currentWord.substring(currentWord.length - 3);
                   if (letterPairs[context]) {
                       for (const [nextLetter, weight] of Object.entries(letterPairs[context])) {
                           predictions[nextLetter] = (predictions[nextLetter] || 0) + weight * 4;
                       }
                   }
               }
               
               // Try 2-character context
               if (currentWord.length >= 2) {
                   const context = currentWord.substring(currentWord.length - 2);
                   if (letterPairs[context]) {
                       for (const [nextLetter, weight] of Object.entries(letterPairs[context])) {
                           predictions[nextLetter] = (predictions[nextLetter] || 0) + weight * 2;
                       }
                   }
               }
               
               // Try 1-character context
               const lastChar = currentWord[currentWord.length - 1];
               if (letterPairs[lastChar]) {
                   for (const [nextLetter, weight] of Object.entries(letterPairs[lastChar])) {
                       predictions[nextLetter] = (predictions[nextLetter] || 0) + weight;
                   }
               }
               
               // Word completion predictions
               for (const word of commonWords) {
                   if (word.startsWith(currentWord) && currentWord.length < word.length) {
                       const nextLetter = word[currentWord.length];
                       const completionBonus = word.length === currentWord.length + 1 ? 50 : 25;
                       predictions[nextLetter] = (predictions[nextLetter] || 0) + completionBonus;
                   }
               }
           }
          
           // Convert to array and sort by score
           predictedLetters = Object.entries(predictions)
               .map(([letter, score]) => ({ letter, score }))
               .sort((a, b) => b.score - a.score)
               .slice(0, 8);
       }
       
       // Add common starting letters for new words
       function addCommonStartingLetters(predictions) {
           const commonStarters = {
               't': 30, 'a': 25, 's': 20, 'i': 18, 'h': 16, 'w': 15,
               'o': 14, 'b': 12, 'c': 11, 'd': 10, 'f': 10, 'g': 9,
               'm': 9, 'p': 8, 'l': 8, 'n': 7, 'r': 7, 'u': 6
           };
           
           for (const [letter, weight] of Object.entries(commonStarters)) {
               predictions[letter] = (predictions[letter] || 0) + weight;
           }
       }
      
       // Initialize with minimal base patterns
       function initPredictiveModel() {
           // Start with very basic English patterns
           const basicWords = [
               "the", "and", "that", "have", "for", "not", "with", "you", "this", "but",
               "his", "from", "they", "say", "she", "will", "one", "all", "would", "there"
           ];
           
           for (const word of basicWords) {
               commonWords.add(word);
               learnFromWord(word); // This will build initial patterns
           }
           
           learningStats.words = basicWords.length;
           updateStats();
       }
      
       window.onload = function() {
           createKeyboard();
           initPredictiveModel();
       };
   </script>
</body>
</html>